#! /bin/bash

trkfile="$HOME/.trk"
if [ ! -z "$TRK_FILE" ]; then
    trkfile="$TRK_FILE"
fi

read -r -d '' help <<'EOF'
Usage:
    trk
        shows a report and the current timer, if active
    trk <entry_name>
        starts tracking named entry
    trk s
        stops the current tracking
    trk l
        shows the full entry log
    trk l <search_term>
        shows the entries matching the search
    trk clean
        backup the current trk log and starts anew
    trk e
        edit the log file directly, only for the brave

Options:
    --help -h   Print this help


Notes:
    - trk log is `~/.trk`
EOF


ensure_trkfile_is_present() {
    test -r "$trkfile" && return
    touch "$trkfile"
}

edit_trkfile() {
    $EDITOR "$trkfile"
}

get_timestamp() {
    date '+%s'
}

is_there_a_pending_timer() {
    tail -n1 "$trkfile" | grep '^start' >/dev/null
    return $?
}

stop_timer() {
    local en="$1"
    if is_there_a_pending_timer; then
        echo "stop `get_timestamp`" >> "$trkfile"
    else
        echo "no active timer to stop" 
    fi
}

start_timer() {
    local name="$1"
    is_there_a_pending_timer && stop_timer
    echo "start `get_timestamp` $name" >> "$trkfile"
}

show_current_entry() {
    if is_there_a_pending_timer; then
        tail -n1 "$trkfile"
    else
        echo 'no active timer'
    fi
}

show_filtered_log() {
    local filter="$1"
    grep -A1 "$filter" "$trkfile"
}

show_full_log() {
    cat "$trkfile"
}

show_tags() {
    show_full_log | \
        grep '^start [0-9]* [a-zA-Z0-9_\-\.]*' | \
        sed 's/^start [0-9]* //' | \
        sort | uniq
}

clean_trk() {
    mv "$trkfile" "$trkfile.bak"
}

get_entry_start_timestamps() {
    local entry_name="$1"
    show_full_log | \
        grep "^start [0-9]* $tag$" | \
        sed 's/^start //' | \
        grep -o '^[0-9]* '
}

is_the_current_active_timer_entry() {
    local entry_start_timestamp="$1"
    test `show_full_log | grep -A1 "$entry_start_timestamp" | wc -l` -eq 1
    return $?
}

get_entry_stop_timestamp() {
    local entry_start_timestamp="$1"

    is_the_current_active_timer_entry && return

    show_full_log | \
        grep -A1 "$entry_start_timestamp" \
        | tail -n1 | sed 's/^stop //'
}

get_seconds_spent() {
    local entry_start_time="$1"
    local now="$2"

    if is_the_current_active_timer_entry "$entry_start_time"; then
        entry_stop_time=$now
    else
        entry_stop_time=`get_entry_stop_timestamp "$entry_start_time"`
    fi
    seconds_spent=`expr $entry_stop_time - $entry_start_time`
    echo $seconds_spent
}

print_entry_info() {
    local entry_start_time="$1"
    local tag="$2"
    local now="$3"

    echo "> $entry_start_time $tag"
    if is_the_current_active_timer_entry "$entry_start_time"; then
        entry_stop_time=$now
        echo "+ current timer"
    else
        entry_stop_time=`get_entry_stop_timestamp "$entry_start_time"`
        echo "x $entry_stop_time"
    fi
    seconds_spent=`get_seconds_spent $entry_start_time $now`
    echo "spent $seconds_spent seconds"
}

get_humanized_interval() {
    local seconds_spent="$1"
    
    timeline="$seconds_spent seconds"
    minutes_spent=`expr $seconds_spent / 60`
    hours_spent=`expr $minutes_spent / 60`
    if [ $seconds_spent -ge 60 ]; then
        timeline="$minutes_spent minutes"
    fi
    if [ $minutes_spent -ge 60 ]; then
        hours_in_minutes=`expr $hours_spent \* 60`
        minutes_remainder=`expr $minutes_spent - $hours_in_minutes`
        timeline="$hours_spent hours, $minutes_remainder minutes"
    fi

    echo "$timeline"
}

print_tag_info() {
    local tag="$1"
    local seconds_spent="$2"
    echo "spent `get_humanized_interval "$seconds_spent"` on $tag"
}

show_report() {
    local now=`get_timestamp`

    echo "report (with active timer included):"
    echo
    for tag in `show_tags`; do
        total_seconds_spent=0
        for entry_start_time in `get_entry_start_timestamps "$tag"`; do
            seconds_spent=`get_seconds_spent $entry_start_time $now`
            total_seconds_spent=`expr $total_seconds_spent + $seconds_spent`
        done
        print_tag_info "$tag" "$total_seconds_spent"
    done
}

show_current_entry() {
    if ! is_there_a_pending_timer; then
        echo 'no active timer'
        return
    fi
    local now=`get_timestamp`
    local current_entry_line=`tail -n1 "$trkfile" `
    local entry_start_time=`echo "$current_entry_line" | sed 's/^start \([0-9]*\) .*$/\1/'`
    local tag=`echo "$current_entry_line" | sed 's/^start [0-9]* \(.*\)$/\1/'`

    local seconds_spent=`get_seconds_spent "$entry_start_time" "$now"`
    local humanized_time_spent=`get_humanized_interval "$seconds_spent"`

    echo "active timer:"
    echo "$humanized_time_spent spent on $tag"
}

command="$1"

ensure_trkfile_is_present

if [ -z "$command" ]; then
    show_report
    echo
    show_current_entry
elif [ "$command" = "s" ]; then
    stop_timer
elif [ "$command" = "l" ]; then
    filter="$2"
    if [ -z "$filter" ]; then
        show_full_log
    else
        show_filtered_log "$filter"
    fi
elif [ "$command" = "clean" ]; then
    clean_trk
elif [ "$command" = "e" ]; then
    edit_trkfile
elif [ ! -z "$command" ]; then
    entry_name="$command"
    start_timer "$entry_name"
else
    echo "$help"
fi

