#! /bin/bash

# Notes:
# - it's important to keep entries timestamps (start and stop) unique
#   because the timestamp number is like an entry id
#   and timestamps will be grep-ed by some functions
# - for now keep entry tags 1 word long, I'll fix that someday


trkfile_date_format="%Y-%m-%d"
trkdir_default="$HOME/.trk"
trkdir="$trkdir_default"
if [ ! -z "$TRK_DIR" ]; then
    trkdir="$TRK_DIR"
fi
trkfile="$trkdir/`date +$trkfile_date_format`.log"

read -r -d '' help <<EOF
Usage:
    trk
        shows a "today" report and the current timer, if active
    trk <entry_name>
        starts timer tracking a named entry
    trk t
        terminates the current timer
    trk r
        shows a report of all entries
    trk l
        lists the trk files
    trk a <entry_name> <time_spent>
        adds a new entry manually, with the specified time spent
        e.g.: "1 hour", "90 minutes", "2 hours", etc.
    trk e [trk_file]
        edit the trk file directly, only for the brave
    trk clean
        backup the current trk file and starts anew
    trk y
        sync: commits eventual changes and do a pull/push of the trk dir
    trk g git_args
        runs git with git_args in the trk dir
    trk help | h
        shows help

Options:
    --help -h   Print this help

Notes:
    - trk default dir is [$trkdir_default]
    - to change default trk dir set TRK_DIR env var
    - to show debug infos set TRK_DEBUG env var to something
EOF

log() {
    local msg="$1"
    test -z "$TRK_DEBUG" || echo "$msg" >&2
}

ensure_trkdir_is_present() {
    test -d $trkdir || mkdir -p $trkdir
}

ensure_trkfile_is_present() {
    ensure_trkdir_is_present
    test -f "$trkfile" || touch "$trkfile"
}

edit_trkfile() {
    local filename="$1"
    local filepath="$trkdir/$file_name.log"

    if test -z "$filename"; then
        $EDITOR "$trkfile"
    elif test -r ; then
        $EDITOR "$filepath"
    else
        echo "no trk file named [$filename]" >&2
    fi
}

get_timestamp() {
    date '+%s'
}

is_there_a_pending_timer() {
    get_last_trk_line | grep '^start' >/dev/null
    return $?
}

stop_timer() {
    local en="$1"
    if is_there_a_pending_timer; then
        echo "stop  `get_timestamp`" >> "$trkfile"
    else
        echo "no active timer to stop" 
    fi
}

start_timer() {
    local name="$1"
    local now=`get_timestamp`

    ensure_trkfile_is_present
    is_there_a_pending_timer && stop_timer
    if grep "$now" "$trkfile" >/dev/null; then
        now=`expr $now + 1`
    fi
    echo "start $now $name" >> "$trkfile"
}

show_current_entry() {
    if is_there_a_pending_timer; then
        get_last_trk_line
    else
        echo 'no active timer'
    fi
}

show_filtered_log() {
    local filter="$1"
    grep -A1 "$filter" "$trkfile"
}

show_today_log() {
    test -r $trkfile && cat "$trkfile"
}

show_full_log() {
    if [ 0 -eq `ls $trkdir | wc -l` ]; then
        return
    fi
    cat $trkdir/*.log
}

show_today_tags() {
    show_today_log | \
        grep '^start [0-9]* [a-zA-Z0-9_\-\.]*' | \
        sed 's/^start [0-9]* //' | \
        sort | uniq
}

show_tags() {
    show_full_log | \
        grep '^start [0-9]* [a-zA-Z0-9_\-\.]*' | \
        sed 's/^start [0-9]* //' | \
        sort | uniq
}

get_today_entry_start_timestamps() {
    local entry_name="$1"
    show_today_log | \
        grep "^start [0-9]* $tag$" | \
        sed 's/^start //' | \
        grep -o '^[0-9]* '
}

get_entry_start_timestamps() {
    local entry_name="$1"
    show_full_log | \
        grep "^start [0-9]* $tag$" | \
        sed 's/^start //' | \
        grep -o '^[0-9]* '
}


is_the_current_active_timer_entry() {
    local entry_start_timestamp="$1"
    test `show_today_log | grep -A1 "$entry_start_timestamp" | wc -l` -eq 1
    return $?
}

get_entry_stop_timestamp() {
    local entry_start_timestamp="$1"

    is_the_current_active_timer_entry && return

    stopline=`show_full_log | grep -A1 "$entry_start_timestamp" | tail -n1 | sed 's/^stop //'`
    if ! echo "$stopline" | grep "^start" &>/dev/null; then
        echo $stopline 
    fi
}

extract_tag_from_start_entry() {
    local entry_line="$1"
    local tag=`echo "$entry_line" | sed 's/^start [0-9]* \(.*\)$/\1/'`
    echo "$tag"
}

extract_timestamp_from_start_entry() {
    local entry_line="$1"
    local entry_start_time=`echo "$entry_line" | sed 's/^start \([0-9]*\) .*$/\1/'`
    echo "$entry_start_time"
}

get_seconds_spent() {
    local entry_start_time="$1"
    local now="$2"

    log "now: [$now]"

    if is_the_current_active_timer_entry "$entry_start_time"; then
        entry_stop_time=$now
    else
        entry_stop_time=`get_entry_stop_timestamp "$entry_start_time"`
    fi
    log "entry_start_time: [$entry_start_time]"
    log "entry_stop_time: [$entry_stop_time]"
    if test -z "$entry_stop_time"; then
        unclosed_file=`grep -rlF $entry_start_time $trkdir`
        echo "!! unclosed entry in file [$unclosed_file]" >&2
        entry_stop_time="$entry_start_time"
    fi
    seconds_spent=`expr $entry_stop_time - $entry_start_time`
    echo $seconds_spent
}

get_humanized_interval() {
    local seconds_spent="$1"
    
    log "secs spent: [$seconds_spent]"

    timeline="$seconds_spent seconds"
    minutes_spent=`expr $seconds_spent / 60`
    hours_spent=`expr $minutes_spent / 60`
    if [ $seconds_spent -ge 60 ]; then
        timeline="$minutes_spent minutes"
    fi
    if [ $minutes_spent -ge 60 ]; then
        hours_in_minutes=`expr $hours_spent \* 60`
        minutes_remainder=`expr $minutes_spent - $hours_in_minutes`
        timeline="$hours_spent hours, $minutes_remainder minutes"
    fi

    echo "$timeline"
}

add_entry() {
    local entry_name="$1"
    local time_interval="$2"

    if [ -z "$entry_name" ]; then
        echo "missing entry_name"
        exit 1
    fi
    if [ -z "$time_interval" ]; then
        echo "missing time_interval"
        exit 1
    fi

    local now=`get_timestamp`

    stop_time=`date -d "$time_interval" '+%s'`

    if [ $now -ge "$stop_time" ]; then
        echo "invalid time interval"
        return 1
    fi

    if is_there_a_pending_timer; then
        local last_entry_line=`get_last_trk_line`
        local tag_to_restart=`extract_tag_from_start_entry "$last_entry_line"`
        stop_timer
    fi

    echo "start $now $entry_name" >> "$trkfile"
    echo "stop  $stop_time" >> "$trkfile"

    if [ ! -z "$tag_to_restart" ]; then
        restart_time=`expr $now + 1`
        echo "start $restart_time $tag_to_restart" >> "$trkfile"
    fi
}

get_last_trk_line() {
    test -r $trkfile && tail -n1 "$trkfile"
}

print_tag_info() {
    local tag="$1"
    local seconds_spent="$2"
    echo "spent `get_humanized_interval "$seconds_spent"` on $tag"
}

show_today_report() {
    local now=`get_timestamp`

    echo "report (with active timer included):"
    echo
    total_seconds_spent=0
    for tag in `show_today_tags`; do
        tag_seconds_spent=0
        for entry_start_time in `get_today_entry_start_timestamps "$tag"`; do
            seconds_spent=`get_seconds_spent $entry_start_time $now`
            tag_seconds_spent=`expr $tag_seconds_spent + $seconds_spent`
        done
        print_tag_info "$tag" "$tag_seconds_spent"
        total_seconds_spent=`expr $total_seconds_spent + $tag_seconds_spent`
    done
    echo
    echo "total time spent: [`get_humanized_interval "$total_seconds_spent"`]"
}

show_current_entry() {
    if ! is_there_a_pending_timer; then
        echo 'no active timer'
        return
    fi
    local now=`get_timestamp`
    local current_entry_line=`get_last_trk_line`
    local entry_start_time=`extract_timestamp_from_start_entry "$current_entry_line"`
    local tag=`extract_tag_from_start_entry "$current_entry_line"`

    log "entry_start_time: [$entry_start_time]"
    log "tag: [$tag]"

    local seconds_spent=`get_seconds_spent "$entry_start_time" "$now"`
    local humanized_time_spent=`get_humanized_interval "$seconds_spent"`

    echo "active timer:"
    echo "$humanized_time_spent spent on $tag"
}

show_report() {
    local from="$1"
    local to="$2"
    local now=`get_timestamp`

    echo "all entries report:"
    echo
    total_seconds_spent=0
    for tag in `show_tags`; do
        tag_seconds_spent=0
        for entry_start_time in `get_entry_start_timestamps "$tag"`; do
            seconds_spent=`get_seconds_spent $entry_start_time $now`
            tag_seconds_spent=`expr $tag_seconds_spent + $seconds_spent`
        done
        print_tag_info "$tag" "$tag_seconds_spent"
        total_seconds_spent=`expr $total_seconds_spent + $tag_seconds_spent`
    done
    echo
    echo "total time spent: [`get_humanized_interval "$total_seconds_spent"`]"
}

clean_trk() {
    mv "$trkfile" "$trkfile.bak"
}

ensure_trkdir_is_present

command="$1"

if [ -z "$command" ]; then
    show_today_report
    echo
    show_current_entry
    echo
    echo "run [`basename $0` h] for help"

elif [ "$command" = "s" ] \
    || [ "$command" = "t" ]; then
    stop_timer

elif [ "$command" = "l" ]; then
    ls -1 $trkdir | sed 's/\.log//'

elif [ "$command" = "e" ]; then
    file_name="$2"
    edit_trkfile $file_name

elif [ "$command" = "a" ]; then
    entry_name="$2"
    shift 2
    time_spent="$@"
    add_entry "$entry_name" "$time_spent"

elif [ "$command" = "r" ]; then
    from="$2"
    to="$3"
    show_report $from $to

elif [ "$command" = "y" ]; then
    cd $trkdir
    git status | grep 'nothing to commit' &>/dev/null
    test $? = 1 && git add -A && git commit -am 'trk autosync'
    git pull && git push

elif [ "$command" = "g" ]; then
    shift 1
    cd $trkdir
    git $@

elif [ "$command" = "clean" ]; then
    clean_trk

elif [ "$command" = "--help" ] \
    || [ "$command" = "-h" ] \
    || [ "$command" = "help" ] \
    || [ "$command" = "h" ] ; then
    echo "$help"
else
    entry_name="$command"
    start_timer "$entry_name"
fi

